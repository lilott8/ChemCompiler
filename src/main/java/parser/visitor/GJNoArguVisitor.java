//
// Generated by JTB 1.3.2
//

package parser.visitor;

import parser.ast.AllowedArguments;
import parser.ast.AllowedArgumentsRest;
import parser.ast.AndExpression;
import parser.ast.ArgumentList;
import parser.ast.AssignmentStatement;
import parser.ast.BSProgram;
import parser.ast.BranchStatement;
import parser.ast.Conditional;
import parser.ast.ConditionalParenthesis;
import parser.ast.DetectStatement;
import parser.ast.DivideExpression;
import parser.ast.DrainStatement;
import parser.ast.ElseBranchStatement;
import parser.ast.ElseIfBranchStatement;
import parser.ast.EqualityExpression;
import parser.ast.FalseLiteral;
import parser.ast.FormalParameter;
import parser.ast.FormalParameterList;
import parser.ast.FormalParameterRest;
import parser.ast.FunctionDefinition;
import parser.ast.FunctionInvoke;
import parser.ast.GreaterThanEqualExpression;
import parser.ast.GreaterThanExpression;
import parser.ast.HeatStatement;
import parser.ast.Identifier;
import parser.ast.IntegerLiteral;
import parser.ast.LessThanEqualExpression;
import parser.ast.LessThanExpression;
import parser.ast.Manifest;
import parser.ast.MatLiteral;
import parser.ast.MathParenthesis;
import parser.ast.MathStatement;
import parser.ast.MinusExpression;
import parser.ast.MixStatement;
import parser.ast.Module;
import parser.ast.NatLiteral;
import parser.ast.NodeList;
import parser.ast.NodeListOptional;
import parser.ast.NodeOptional;
import parser.ast.NodeSequence;
import parser.ast.NodeToken;
import parser.ast.NotEqualExpression;
import parser.ast.NotExpression;
import parser.ast.OrExpression;
import parser.ast.PlusExpression;
import parser.ast.PrimaryExpression;
import parser.ast.Primitives;
import parser.ast.RealLiteral;
import parser.ast.RepeatStatement;
import parser.ast.RightOp;
import parser.ast.SplitStatement;
import parser.ast.Statements;
import parser.ast.Stationary;
import parser.ast.TimesExpression;
import parser.ast.TrueLiteral;
import parser.ast.Type;
import parser.ast.TypingList;
import parser.ast.TypingRest;
import parser.ast.WhileStatement;

/**
 * All GJ visitors with no argument must implement this interface.
 */

public interface GJNoArguVisitor<R> {

    //
    // GJ Auto class visitors with no argument
    //

    R visit(NodeList n);

    R visit(NodeListOptional n);

    R visit(NodeOptional n);

    R visit(NodeSequence n);

    R visit(NodeToken n);

    //
    // User-generated visitor methods below
    //

    /**
     * f0 -> ( Module() )*
     * f1 -> ( Stationary() )*
     * f2 -> ( Manifest() )+
     * f3 -> <FUNCTIONS>
     * f4 -> ( FunctionDefinition() )*
     * f5 -> <INSTRUCTIONS>
     * f6 -> ( Statements() )+
     * f7 -> <EOF>
     */
    R visit(BSProgram n);

    /**
     * f0 -> <MODULE>
     * f1 -> Identifier()
     */
    R visit(Module n);

    /**
     * f0 -> <STATIONARY>
     * f1 -> ( TypingList() )?
     * f2 -> PrimaryExpression()
     */
    R visit(Stationary n);

    /**
     * f0 -> <MANIFEST>
     * f1 -> ( TypingList() )?
     * f2 -> PrimaryExpression()
     */
    R visit(Manifest n);

    /**
     * f0 -> <FUNCTION>
     * f1 -> Identifier()
     * f2 -> <LPAREN>
     * f3 -> ( FormalParameterList() )*
     * f4 -> <RPAREN>
     * f5 -> ( <COLON> TypingList() )?
     * f6 -> <LBRACE>
     * f7 -> ( Statements() )+
     * f8 -> ( <RETURN> Identifier() )?
     * f9 -> <RBRACE>
     */
    R visit(FunctionDefinition n);

    /**
     * f0 -> AssignmentStatement()
     * | BranchStatement()
     * | RepeatStatement()
     * | WhileStatement()
     * | HeatStatement()
     * | DrainStatement()
     * | FunctionInvoke()
     */
    R visit(Statements n);

    /**
     * f0 -> ( TypingList() )*
     * f1 -> Identifier()
     * f2 -> <ASSIGN>
     * f3 -> RightOp()
     */
    R visit(AssignmentStatement n);

    /**
     * f0 -> Type()
     * f1 -> ( TypingRest() )*
     */
    R visit(TypingList n);

    /**
     * f0 -> MatLiteral()
     * | NatLiteral()
     * | RealLiteral()
     */
    R visit(Type n);

    /**
     * f0 -> <COMMA>
     * f1 -> Type()
     */
    R visit(TypingRest n);

    /**
     * f0 -> FormalParameter()
     * f1 -> ( FormalParameterRest() )*
     */
    R visit(FormalParameterList n);

    /**
     * f0 -> ( TypingList() )*
     * f1 -> Identifier()
     */
    R visit(FormalParameter n);

    /**
     * f0 -> <COMMA>
     * f1 -> FormalParameter()
     */
    R visit(FormalParameterRest n);

    /**
     * f0 -> <MIX>
     * f1 -> PrimaryExpression()
     * f2 -> <WITH>
     * f3 -> PrimaryExpression()
     * f4 -> ( <FOR> IntegerLiteral() )?
     */
    R visit(MixStatement n);

    /**
     * f0 -> <SPLIT>
     * f1 -> PrimaryExpression()
     * f2 -> <INTO>
     * f3 -> IntegerLiteral()
     */
    R visit(SplitStatement n);

    /**
     * f0 -> <DRAIN>
     * f1 -> PrimaryExpression()
     */
    R visit(DrainStatement n);

    /**
     * f0 -> <HEAT>
     * f1 -> PrimaryExpression()
     * f2 -> <AT>
     * f3 -> IntegerLiteral()
     * f4 -> ( <FOR> IntegerLiteral() )?
     */
    R visit(HeatStatement n);

    /**
     * f0 -> <DETECT>
     * f1 -> PrimaryExpression()
     * f2 -> <ON>
     * f3 -> PrimaryExpression()
     * f4 -> ( <FOR> IntegerLiteral() )?
     */
    R visit(DetectStatement n);

    /**
     * f0 -> <REPEAT>
     * f1 -> ( IntegerLiteral() | Identifier() )
     * f2 -> <TIMES>
     * f3 -> <LBRACE>
     * f4 -> ( Statements() )+
     * f5 -> <RBRACE>
     */
    R visit(RepeatStatement n);

    /**
     * f0 -> <WHILE>
     * f1 -> <LPAREN>
     * f2 -> Conditional()
     * f3 -> <RPAREN>
     * f4 -> <LBRACE>
     * f5 -> ( Statements() )+
     * f6 -> <RBRACE>
     */
    R visit(WhileStatement n);

    /**
     * f0 -> <IF>
     * f1 -> <LPAREN>
     * f2 -> Conditional()
     * f3 -> <RPAREN>
     * f4 -> <LBRACE>
     * f5 -> ( Statements() )+
     * f6 -> <RBRACE>
     * f7 -> ( ElseIfBranchStatement() )*
     * f8 -> ( ElseBranchStatement() )?
     */
    R visit(BranchStatement n);

    /**
     * f0 -> <ELSE_IF>
     * f1 -> <LPAREN>
     * f2 -> Conditional()
     * f3 -> <RPAREN>
     * f4 -> <LBRACE>
     * f5 -> ( Statements() )+
     * f6 -> <RBRACE>
     */
    R visit(ElseIfBranchStatement n);

    /**
     * f0 -> <ELSE>
     * f1 -> <LBRACE>
     * f2 -> ( Statements() )+
     * f3 -> <RBRACE>
     */
    R visit(ElseBranchStatement n);

    /**
     * f0 -> ConditionalParenthesis()
     * | AndExpression()
     * | LessThanExpression()
     * | LessThanEqualExpression()
     * | GreaterThanExpression()
     * | GreaterThanEqualExpression()
     * | NotEqualExpression()
     * | EqualityExpression()
     * | OrExpression()
     */
    R visit(Conditional n);

    /**
     * f0 -> MathParenthesis()
     * | PlusExpression()
     * | MinusExpression()
     * | TimesExpression()
     * | DivideExpression()
     */
    R visit(MathStatement n);

    /**
     * f0 -> Identifier()
     * f1 -> <LPAREN>
     * f2 -> ( ArgumentList() )?
     * f3 -> <RPAREN>
     */
    R visit(FunctionInvoke n);

    /**
     * f0 -> AllowedArguments()
     * f1 -> ( AllowedArgumentsRest() )*
     */
    R visit(ArgumentList n);

    /**
     * f0 -> <COMMA>
     * f1 -> AllowedArguments()
     */
    R visit(AllowedArgumentsRest n);

    /**
     * f0 -> MixStatement()
     * | DetectStatement()
     * | SplitStatement()
     * | FunctionInvoke()
     * | MathStatement()
     */
    R visit(RightOp n);

    /**
     * f0 -> Identifier()
     * | TrueLiteral()
     * | FalseLiteral()
     * | IntegerLiteral()
     * | RealLiteral()
     */
    R visit(PrimaryExpression n);

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    R visit(IntegerLiteral n);

    /**
     * f0 -> <NAT>
     */
    R visit(NatLiteral n);

    /**
     * f0 -> <MAT>
     */
    R visit(MatLiteral n);

    /**
     * f0 -> <REAL>
     */
    R visit(RealLiteral n);

    /**
     * f0 -> <TRUE>
     */
    R visit(TrueLiteral n);

    /**
     * f0 -> <FALSE>
     */
    R visit(FalseLiteral n);

    /**
     * f0 -> <IDENTIFIER>
     */
    R visit(Identifier n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <AND>
     * f2 -> PrimaryExpression()
     */
    R visit(AndExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <LESSTHAN>
     * f2 -> PrimaryExpression()
     */
    R visit(LessThanExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <LESSTHANEQUAL>
     * f2 -> PrimaryExpression()
     */
    R visit(LessThanEqualExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <GREATERTHAN>
     * f2 -> PrimaryExpression()
     */
    R visit(GreaterThanExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <GREATERTHANEQUAL>
     * f2 -> PrimaryExpression()
     */
    R visit(GreaterThanEqualExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <NOTEQUAL>
     * f2 -> PrimaryExpression()
     */
    R visit(NotEqualExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <OR>
     * f2 -> PrimaryExpression()
     */
    R visit(EqualityExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <LESSTHAN>
     * f2 -> PrimaryExpression()
     */
    R visit(OrExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <ADD>
     * f2 -> PrimaryExpression()
     */
    R visit(PlusExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <MINUS>
     * f2 -> PrimaryExpression()
     */
    R visit(MinusExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <MULTIPLY>
     * f2 -> PrimaryExpression()
     */
    R visit(TimesExpression n);

    /**
     * f0 -> PrimaryExpression()
     * f1 -> <DIVIDE>
     * f2 -> PrimaryExpression()
     */
    R visit(DivideExpression n);

    /**
     * f0 -> <BANG>
     * f1 -> PrimaryExpression()
     */
    R visit(NotExpression n);

    /**
     * f0 -> <LPAREN>
     * f1 -> Conditional()
     * f2 -> <RPAREN>
     */
    R visit(ConditionalParenthesis n);

    /**
     * f0 -> <LPAREN>
     * f1 -> MathStatement()
     * f2 -> <RPAREN>
     */
    R visit(MathParenthesis n);

    /**
     * f0 -> Identifier()
     * | Primitives()
     */
    R visit(AllowedArguments n);

    /**
     * f0 -> IntegerLiteral()
     * | RealLiteral()
     * | TrueLiteral()
     * | FalseLiteral()
     */
    R visit(Primitives n);

}

